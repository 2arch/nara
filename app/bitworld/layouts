// components/BitCanvas.tsx
import React, { useRef, useEffect, useCallback, useState } from 'react';
import type { WorldData, Point, WorldEngine, PanStartInfo } from './world.engine.layout'; // Adjust path as needed

// --- Constants --- (Copied and relevant ones kept)
const FONT_FAMILY = 'Terminus, Monaco, Menlo, "DejaVu Sans Mono", "Courier New", monospace';
const GRID_COLOR = '#F2F2F2';
const TEXT_COLOR = '#161616';
const CURSOR_COLOR_PRIMARY = '#FF6B35';
const CURSOR_COLOR_SECONDARY = '#FFA500';
const CURSOR_COLOR_INSERT = '#0066FF'; // Blue color for insert mode
const CURSOR_COLOR_SAVE = '#FFFF00'; // Green color for saving state
const CURSOR_COLOR_ERROR = '#FF0000'; // Red color for error state
const CURSOR_TEXT_COLOR = '#FFFFFF';
const BACKGROUND_COLOR = '#FFFFFF';
const DRAW_GRID = true;
const GRID_LINE_WIDTH = 1;
const CURSOR_TRAIL_FADE_MS = 200; // Time in ms for trail to fully fade

interface CursorTrailPosition {
    x: number;
    y: number;
    timestamp: number;
}

interface BitCanvasProps {
    engine: WorldEngine;
    cursorColorAlternate: boolean;
    className?: string;
}

export function BitCanvas({ engine, cursorColorAlternate, className }: BitCanvasProps) {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const devicePixelRatioRef = useRef(1);
    const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });
    const [cursorTrail, setCursorTrail] = useState<CursorTrailPosition[]>([]);
    const lastCursorPosRef = useRef<Point | null>(null);

    // Refs for smooth panning
    const panStartInfoRef = useRef<PanStartInfo | null>(null);
    const isMiddleMouseDownRef = useRef(false);
    const intermediatePanOffsetRef = useRef<Point>(engine.viewOffset); // Track offset during pan

    // Ref for tracking selection drag state (mouse button down)
    const isSelectingMouseDownRef = useRef(false);

    // --- Resize Handler (Canvas specific) ---
    const handleResize = useCallback(() => {
        const dpr = window.devicePixelRatio || 1;
        devicePixelRatioRef.current = dpr;
        const cssWidth = window.innerWidth;
        const cssHeight = window.innerHeight;
        setCanvasSize({ width: cssWidth, height: cssHeight }); // Update CSS size state

        const canvas = canvasRef.current;
        if (canvas) {
            canvas.width = Math.floor(cssWidth * dpr);
            canvas.height = Math.floor(cssHeight * dpr);
            canvas.style.width = `${cssWidth}px`;
            canvas.style.height = `${cssHeight}px`;
            const ctx = canvas.getContext('2d');
            if (ctx) ctx.imageSmoothingEnabled = false;
        }
    }, []); // Empty deps

    // --- Setup Resize Listener ---
    useEffect(() => {
        handleResize(); // Initial size
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [handleResize]);

    // Track cursor movement for trail effect
    useEffect(() => {
        const currentPos = engine.cursorPos;
        
        // Only add to trail if cursor has actually moved
        if (!lastCursorPosRef.current || 
            currentPos.x !== lastCursorPosRef.current.x || 
            currentPos.y !== lastCursorPosRef.current.y) {
            
            const now = Date.now();
            const newTrailPosition = {
                x: currentPos.x,
                y: currentPos.y,
                timestamp: now
            };
            
            setCursorTrail(prev => {
                // Add new position and filter out old ones
                const cutoffTime = now - CURSOR_TRAIL_FADE_MS;
                const updated = [newTrailPosition, ...prev.filter(pos => pos.timestamp >= cutoffTime)];
                return updated;
            });
            
            lastCursorPosRef.current = {...currentPos};
        }
    }, [engine.cursorPos]);

    // --- Drawing Logic ---
    const draw = useCallback(() => {
        const canvas = canvasRef.current;
        const ctx = canvas?.getContext('2d');
        if (!canvas || !ctx) return;

        const dpr = devicePixelRatioRef.current;
        const { width: cssWidth, height: cssHeight } = canvasSize;
        if (cssWidth === 0 || cssHeight === 0) return;

        const currentZoom = engine.zoomLevel;
        const {
            width: effectiveCharWidth,
            height: effectiveCharHeight,
            fontSize: effectiveFontSize
        } = engine.getEffectiveCharDims(currentZoom);

        // Use intermediate offset if panning, otherwise use engine's state
        const currentOffset = isMiddleMouseDownRef.current ? intermediatePanOffsetRef.current : engine.viewOffset;

        // --- Actual Drawing (Copied from previous `draw` function) ---
        ctx.save();
        ctx.scale(dpr, dpr);
        
        // Replace fillRect with clearRect for transparency
        // ctx.clearRect(0, 0, cssWidth, cssHeight);
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, cssWidth, cssHeight);
        
        ctx.imageSmoothingEnabled = false;
        ctx.font = `${effectiveFontSize}px ${FONT_FAMILY}`;

        // Text rendering bounds (always based on viewport)
        const textStartWorldX = currentOffset.x;
        const textStartWorldY = currentOffset.y;
        const textEndWorldX = textStartWorldX + (cssWidth / effectiveCharWidth);
        const textEndWorldY = textStartWorldY + (cssHeight / effectiveCharHeight);

        if (DRAW_GRID && effectiveCharWidth > 2 && effectiveCharHeight > 2) {
            ctx.strokeStyle = GRID_COLOR;
            ctx.lineWidth = GRID_LINE_WIDTH / dpr;
            ctx.beginPath();
            
            // Grid bounds constrained by focused region if active
            const gridStartX = engine.focusedRegion ? engine.focusedRegion.startX : Math.floor(textStartWorldX);
            const gridEndX = engine.focusedRegion ? engine.focusedRegion.endX + 1 : Math.ceil(textEndWorldX);
            const gridStartY = engine.focusedRegion ? engine.focusedRegion.startY : Math.floor(textStartWorldY);
            const gridEndY = engine.focusedRegion ? engine.focusedRegion.endY + 1 : Math.ceil(textEndWorldY);
            
            for (let worldX = gridStartX; worldX <= gridEndX; worldX++) {
                const screenX = Math.floor((worldX - currentOffset.x) * effectiveCharWidth) + 0.5 / dpr;
                if (screenX >= 0 && screenX <= cssWidth) { 
                    // In focused mode, constrain grid lines to region screen bounds
                    let lineStartY = 0;
                    let lineEndY = cssHeight;
                    if (engine.focusedRegion) {
                        const regionTopScreen = (engine.focusedRegion.startY - currentOffset.y) * effectiveCharHeight;
                        const regionBottomScreen = (engine.focusedRegion.endY + 1 - currentOffset.y) * effectiveCharHeight;
                        lineStartY = Math.max(0, regionTopScreen);
                        lineEndY = Math.min(cssHeight, regionBottomScreen);
                    }
                    ctx.moveTo(screenX, lineStartY); 
                    ctx.lineTo(screenX, lineEndY); 
                }
            }
            for (let worldY = gridStartY; worldY <= gridEndY; worldY++) {
                const screenY = Math.floor((worldY - currentOffset.y) * effectiveCharHeight) + 0.5 / dpr;
                if (screenY >= 0 && screenY <= cssHeight) { 
                    // In focused mode, constrain grid lines to region screen bounds
                    let lineStartX = 0;
                    let lineEndX = cssWidth;
                    if (engine.focusedRegion) {
                        const regionLeftScreen = (engine.focusedRegion.startX - currentOffset.x) * effectiveCharWidth;
                        const regionRightScreen = (engine.focusedRegion.endX + 1 - currentOffset.x) * effectiveCharWidth;
                        lineStartX = Math.max(0, regionLeftScreen);
                        lineEndX = Math.min(cssWidth, regionRightScreen);
                    }
                    ctx.moveTo(lineStartX, screenY); 
                    ctx.lineTo(lineEndX, screenY); 
                }
            }
            ctx.stroke();
        }

        ctx.fillStyle = TEXT_COLOR;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const horizontalTextOffset = effectiveCharWidth / 2;
        const verticalTextOffset = (effectiveCharHeight - effectiveFontSize) / 2;
        for (const key in engine.worldData) {
            const [xStr, yStr] = key.split(',');
            const worldX = parseInt(xStr, 10); 
            const worldY = parseInt(yStr, 10);
            
            // Always render text content (even outside focused region for context)
            
            if (worldX >= textStartWorldX - 5 && worldX <= textEndWorldX + 5 && worldY >= textStartWorldY - 5 && worldY <= textEndWorldY + 5) {
                const char = engine.worldData[key];
                const screenPos = engine.worldToScreen(worldX, worldY, currentZoom, currentOffset);
                if (screenPos.x > -effectiveCharWidth * 2 && screenPos.x < cssWidth + effectiveCharWidth && screenPos.y > -effectiveCharHeight * 2 && screenPos.y < cssHeight + effectiveCharHeight) {
                    ctx.fillText(char, screenPos.x + horizontalTextOffset, screenPos.y + verticalTextOffset);
                }
            }
        }

        // Draw droplets
        for (const droplet of engine.droplets) {
            const dropletScreenPos = engine.worldToScreen(droplet.x, droplet.y, currentZoom, currentOffset);
            
            // Only draw if visible on screen
            if (dropletScreenPos.x >= -effectiveCharWidth && dropletScreenPos.x <= cssWidth + effectiveCharWidth &&
                dropletScreenPos.y >= -effectiveCharHeight && dropletScreenPos.y <= cssHeight + effectiveCharHeight) {
                
                ctx.fillStyle = droplet.color;
                ctx.fillRect(dropletScreenPos.x, dropletScreenPos.y, effectiveCharWidth, effectiveCharHeight);
            }
        }

        // Draw number drops
        for (const numberDrop of engine.numberDrops) {
            const numberScreenPos = engine.worldToScreen(numberDrop.x, numberDrop.y, currentZoom, currentOffset);
            
            // Only draw if visible on screen
            if (numberScreenPos.x >= -effectiveCharWidth && numberScreenPos.x <= cssWidth + effectiveCharWidth &&
                numberScreenPos.y >= -effectiveCharHeight && numberScreenPos.y <= cssHeight + effectiveCharHeight) {
                
                // Draw background rectangle
                ctx.fillStyle = '#E0E0E0';
                ctx.fillRect(numberScreenPos.x, numberScreenPos.y, effectiveCharWidth, effectiveCharHeight);
                
                // Draw the number
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    numberDrop.value.toString(),
                    numberScreenPos.x + effectiveCharWidth / 2,
                    numberScreenPos.y + effectiveCharHeight / 2
                );
            }
        }

        // Draw cursor trail (older positions first, for proper layering)
        const now = Date.now();
        for (let i = cursorTrail.length - 1; i >= 0; i--) {
            const trailPos = cursorTrail[i];
            const age = now - trailPos.timestamp;
            
            // Skip positions that are too old
            if (age > CURSOR_TRAIL_FADE_MS) continue;
            
            // Skip the current position only if it perfectly matches the cursor
            // (avoid duplicate rendering at exact same spot)
            if (age < 20 && 
                trailPos.x === engine.cursorPos.x && 
                trailPos.y === engine.cursorPos.y) continue;
            
            // Calculate opacity based on age (1.0 to 0.0)
            const opacity = 1 - (age / CURSOR_TRAIL_FADE_MS);
            
            const trailScreenPos = engine.worldToScreen(
                trailPos.x, trailPos.y, 
                currentZoom, currentOffset
            );
            
            // Only draw if visible on screen
            if (trailScreenPos.x >= -effectiveCharWidth && 
                trailScreenPos.x <= cssWidth && 
                trailScreenPos.y >= -effectiveCharHeight && 
                trailScreenPos.y <= cssHeight) {
                
                // Draw faded cursor rectangle
                const baseColor = cursorColorAlternate ? 
                    CURSOR_COLOR_SECONDARY : CURSOR_COLOR_PRIMARY;
                ctx.fillStyle = `rgba(${hexToRgb(baseColor)}, ${opacity})`;
                ctx.fillRect(
                    trailScreenPos.x, 
                    trailScreenPos.y, 
                    effectiveCharWidth, 
                    effectiveCharHeight
                );
            }
        }

        const cursorScreenPos = engine.worldToScreen(engine.cursorPos.x, engine.cursorPos.y, currentZoom, currentOffset);
        if (cursorScreenPos.x >= -effectiveCharWidth && cursorScreenPos.x <= cssWidth && cursorScreenPos.y >= -effectiveCharHeight && cursorScreenPos.y <= cssHeight) {
            // Determine cursor color based on engine state
            if (engine.worldPersistenceError) {
                ctx.fillStyle = CURSOR_COLOR_ERROR;
            } else if (engine.isSavingWorld) {
                ctx.fillStyle = CURSOR_COLOR_SAVE;
            } else if (engine.isInsertMode) {
                ctx.fillStyle = CURSOR_COLOR_INSERT;
            } else {
                ctx.fillStyle = cursorColorAlternate ? CURSOR_COLOR_SECONDARY : CURSOR_COLOR_PRIMARY;
            }
            
            ctx.fillRect(cursorScreenPos.x, cursorScreenPos.y, effectiveCharWidth, effectiveCharHeight);
            const key = `${engine.cursorPos.x},${engine.cursorPos.y}`;
            if (engine.worldData[key]) {
                ctx.fillStyle = CURSOR_TEXT_COLOR;
                ctx.fillText(engine.worldData[key], cursorScreenPos.x + horizontalTextOffset, cursorScreenPos.y + verticalTextOffset);
            }
        }

        // Draw regions (only in infinite canvas mode)
        if (!engine.focusedRegion) {
            for (const region of engine.regions) {
            const regionStartScreen = engine.worldToScreen(region.startX, region.startY, currentZoom, currentOffset);
            const regionEndScreen = engine.worldToScreen(region.endX, region.endY, currentZoom, currentOffset);
            
            const rectX = Math.min(regionStartScreen.x, regionEndScreen.x);
            const rectY = Math.min(regionStartScreen.y, regionEndScreen.y);
            const rectWidth = (region.endX - region.startX + 1) * effectiveCharWidth;
            const rectHeight = (region.endY - region.startY + 1) * effectiveCharHeight;
            
            // Draw region border
            ctx.strokeStyle = region.color || '#E0E0E0';
            ctx.lineWidth = region.parentId ? 1 : 2; // Thicker border for root regions
            ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
            
            // Fill with subtle background for nested regions
            if (region.parentId) {
                ctx.fillStyle = `${region.color}20`; // Very transparent fill
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
            }
            
            // Draw region label if present (inside the box)
            if (region.name) {
                ctx.fillStyle = '#666666';
                ctx.font = `${Math.max(10, effectiveFontSize * 0.8)}px ${FONT_FAMILY}`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                // Show label inside the box at top-left corner
                ctx.fillText(region.name, rectX + 2, rectY + 2);
            }
        }
        }

        // Draw auto-detected textboxes (only visible ones)
        for (const textBox of engine.textBoxes) {
            if (!textBox.isVisible) continue;
            
            const textBoxStartScreen = engine.worldToScreen(textBox.startX, textBox.startY, currentZoom, currentOffset);
            const textBoxEndScreen = engine.worldToScreen(textBox.endX, textBox.endY, currentZoom, currentOffset);
            
            const rectX = Math.min(textBoxStartScreen.x, textBoxEndScreen.x);
            const rectY = Math.min(textBoxStartScreen.y, textBoxEndScreen.y);
            const rectWidth = (textBox.endX - textBox.startX + 1) * effectiveCharWidth;
            const rectHeight = (textBox.endY - textBox.startY + 1) * effectiveCharHeight;
            
            // Draw green border for auto-detected textboxes
            ctx.strokeStyle = '#00AA00';
            ctx.lineWidth = 1;
            ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
        }

        // Draw preview region if active
        if (engine.previewRegion) {
            // Draw all layouts in the preview
            for (const layout of engine.previewRegion.layouts) {
                const previewStartScreen = engine.worldToScreen(layout.startX, layout.startY, currentZoom, currentOffset);
                const previewWidth = layout.width * effectiveCharWidth;
                const previewHeight = layout.height * effectiveCharHeight;
                
                // Draw dashed border for preview (uniform styling)
                ctx.strokeStyle = '#E0E0E0';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]); // Dashed line pattern
                ctx.strokeRect(previewStartScreen.x, previewStartScreen.y, previewWidth, previewHeight);
                
                // Draw label if present (inside the preview box)
                if (layout.label) {
                    ctx.fillStyle = '#666666';
                    ctx.font = `${Math.max(10, effectiveFontSize * 0.8)}px ${FONT_FAMILY}`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(layout.label, previewStartScreen.x + 2, previewStartScreen.y + 2);
                }
            }
            ctx.setLineDash([]); // Reset to solid lines
        }

        // Draw selection rectangle if engine has a selection
        if (engine.selectionStart && engine.selectionEnd) {
            const { width: effectiveCharWidth, height: effectiveCharHeight } = engine.getEffectiveCharDims(currentZoom);

            // Ensure start is top-left and end is bottom-right for screen coordinates
            const screenStart = engine.worldToScreen(engine.selectionStart.x, engine.selectionStart.y, currentZoom, currentOffset);
            const screenEnd = engine.worldToScreen(engine.selectionEnd.x, engine.selectionEnd.y, currentZoom, currentOffset);

            // Calculate screen rectangle coordinates, ensuring start is top-left
            const rectX = Math.min(screenStart.x, screenEnd.x);
            const rectY = Math.min(screenStart.y, screenEnd.y);
            // Width/Height calculation needs to account for the character dimensions
            const selStartXWorld = Math.min(engine.selectionStart.x, engine.selectionEnd.x);
            const selStartYWorld = Math.min(engine.selectionStart.y, engine.selectionEnd.y);
            const selEndXWorld = Math.max(engine.selectionStart.x, engine.selectionEnd.x);
            const selEndYWorld = Math.max(engine.selectionStart.y, engine.selectionEnd.y);

            const rectWidth = (selEndXWorld - selStartXWorld + 1) * effectiveCharWidth;
            const rectHeight = (selEndYWorld - selStartYWorld + 1) * effectiveCharHeight;


            // Draw semi-transparent selection
            ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
            ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
        }

        ctx.restore();
        // --- End Drawing ---
    }, [engine, canvasSize, cursorColorAlternate, isMiddleMouseDownRef.current, intermediatePanOffsetRef.current, cursorTrail]);


    // --- Drawing Loop Effect ---
    useEffect(() => {
        let animationFrameId: number;
        const renderLoop = () => {
            draw();
            animationFrameId = requestAnimationFrame(renderLoop);
        };
        renderLoop();
        return () => cancelAnimationFrame(animationFrameId);
    }, [draw]); // Rerun if draw changes

    // Add this effect to handle wheel events with non-passive option
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const wheelHandler = (e: WheelEvent) => {
            const rect = canvas.getBoundingClientRect();
            engine.handleCanvasWheel(
                e.deltaX, e.deltaY,
                e.clientX - rect.left, e.clientY - rect.top,
                e.ctrlKey || e.metaKey
            );
            
            // Prevent default if we're handling this ourselves
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
            }
        };
        
        // Add wheel listener with non-passive option
        canvas.addEventListener('wheel', wheelHandler, { passive: false });
        
        // Cleanup function
        return () => {
            canvas.removeEventListener('wheel', wheelHandler);
        };
    }, [engine]);

    // --- Event Handlers (Attached to Canvas) ---
    const handleCanvasClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
        if (e.button !== 0) return; // Only left clicks

        // Don't process click if it was the end of a pan
        if (panStartInfoRef.current) {
            panStartInfoRef.current = null;
            if (isMiddleMouseDownRef.current) return;
        }
        
        // Get canvas-relative coordinates
        const rect = canvasRef.current?.getBoundingClientRect();
        if (!rect) return;
        
        // Pass false for clearSelection - let the engine decide
        engine.handleCanvasClick(e.clientX - rect.left, e.clientY - rect.top, false, e.shiftKey);
        canvasRef.current?.focus(); // Ensure focus for keyboard
    }, [engine]);

    const handleCanvasDoubleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
        if (e.button !== 0) return; // Only left clicks
        
        const rect = canvasRef.current?.getBoundingClientRect();
        if (!rect) return;
        
        const worldPos = engine.screenToWorld(e.clientX - rect.left, e.clientY - rect.top, engine.zoomLevel, engine.viewOffset);
        const region = engine.getRegionAt(worldPos.x, worldPos.y);
        
        if (region) {
            engine.focusRegion(region.id);
        }
    }, [engine]);
    
    const handleCanvasMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
        const rect = canvasRef.current?.getBoundingClientRect();
        if (!rect) return;

        if (e.button === 1) { // Middle mouse button - panning
            e.preventDefault(); // Prevent default scrolling behavior
            isMiddleMouseDownRef.current = true;
            const info = engine.handlePanStart(e.clientX, e.clientY);
            panStartInfoRef.current = info;
            intermediatePanOffsetRef.current = { ...engine.viewOffset }; // Clone to avoid reference issues
            if (canvasRef.current) canvasRef.current.style.cursor = 'grabbing';
        } else if (e.button === 0) { // Left mouse button - selection start
            isSelectingMouseDownRef.current = true; // Track mouse down state
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            engine.handleSelectionStart(x, y); // Let the engine manage selection state
            canvasRef.current?.focus();
        }
    }, [engine]);

    const handleCanvasMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
        const rect = canvasRef.current?.getBoundingClientRect();
        if (!rect) return;

        if (isMiddleMouseDownRef.current && panStartInfoRef.current) {
            // Handle panning move
            intermediatePanOffsetRef.current = engine.handlePanMove(e.clientX, e.clientY, panStartInfoRef.current);
        } else if (isSelectingMouseDownRef.current) { // Check mouse down ref
            // Handle selection move
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            engine.handleSelectionMove(x, y); // Update engine's selection end
        }
    }, [engine]);

    const handleCanvasMouseUp = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
        if (isMiddleMouseDownRef.current && e.button === 1) { // Middle mouse button - panning end
            isMiddleMouseDownRef.current = false;
            engine.handlePanEnd(intermediatePanOffsetRef.current); // Commit final offset
            panStartInfoRef.current = null;
            if (canvasRef.current) canvasRef.current.style.cursor = 'text';
        }

        if (isSelectingMouseDownRef.current && e.button === 0) { // Left mouse button - selection end
            isSelectingMouseDownRef.current = false; // Stop tracking mouse down state
            engine.handleSelectionEnd(); // Finalize selection state in engine
        }
    }, [engine]);

    const handleCanvasMouseLeave = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
        // End panning if mouse leaves canvas
        if (isMiddleMouseDownRef.current) {
            isMiddleMouseDownRef.current = false;
            engine.handlePanEnd(intermediatePanOffsetRef.current);
            panStartInfoRef.current = null;
            if (canvasRef.current) canvasRef.current.style.cursor = 'text';
        }

        // End selection if mouse leaves canvas during selection drag
        if (isSelectingMouseDownRef.current) { // Use the ref tracking mouse down state
             isSelectingMouseDownRef.current = false; // Stop tracking internally
             engine.handleSelectionEnd(); // Finalize selection in engine
        }
    }, [engine]);

    const handleCanvasKeyDown = useCallback((e: React.KeyboardEvent<HTMLCanvasElement>) => {
        // Pass shift key status to the engine's handler
        const preventDefault = engine.handleKeyDown(e.key, e.ctrlKey, e.metaKey, e.shiftKey);
        if (preventDefault) {
            e.preventDefault();
        }
    }, [engine]);

    return (
        <canvas
            ref={canvasRef}
            className={className}
            onClick={handleCanvasClick}
            onDoubleClick={handleCanvasDoubleClick}
            onMouseDown={handleCanvasMouseDown}
            onMouseMove={handleCanvasMouseMove}
            onMouseUp={handleCanvasMouseUp}
            onMouseLeave={handleCanvasMouseLeave}
            onKeyDown={handleCanvasKeyDown}
            tabIndex={0}
            style={{ display: 'block', outline: 'none', width: '100%', height: '100%', cursor: 'text' /* Default cursor */ }}
        />
    );
}

// Helper function to convert hex color to RGB components
function hexToRgb(hex: string): string {
    // Remove # if present
    hex = hex.replace(/^#/, '');
    
    // Parse hex values
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return `${r}, ${g}, ${b}`;
}